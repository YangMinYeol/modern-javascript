## 이벤트

#### 마우스 이벤트

- `click`
- `contextmenu`
- `mouseover/mouseout`
- `mousedown/mouseup`
- `mousemove`

#### 폼 요소 이벤트

- `submit`
- `focus`

#### 키보드 이벤트

- `keydown/keyup`

#### 문서 이벤트

- `DOMContentLoaded` - HTML이 전부 로드 및 처리되어 DOM 생성이 완료되었을 때 발생

#### CSS 이벤트

- `transitionend` - CSS 애니메이션이 종료되었을 때 발생

## 이벤트 핸들러

#### HTML 속성

- HTML안의 속성을 통해 핸들러를 할당한다.
- 대소문자를 구분하지 않는다.
- 긴 코드를 HTML 속성값으로 사용하는 것은 추천하지 않는다. 만약 코드가 길다면, 함수를 만들어서 이를 호출하는 방법을 사용

#### DOM 프로퍼티

- 대소문자를 구분한다.
  > elem.onclick

#### addEventListener

- 핸들러를 여러개 할당할 수 있다.
- 핸들러 삭제는 `removeEventListener`로 한다.

## 이벤트 객체

- 이벤트에 관환 상세한 정보를 넣은 다음, 핸들러에 인수 형태로 전달한다.

## 버블링

- 이벤트가 상위 요소로 전파되는 단계
- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이과정이 반복되면서 요소 각각에 할당된 핸들러가 동작한다.
- 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품과 닮아 버블링이라 부른다.

#### 버블링 중단하기

- `event.stopPropagation()`을 사용하면 된다.
- 이벤트 버블링을 막아야하는 경우는 거의없으며 버블링은 꼭 멈춰야 하는 명백한 상황이 아니라면 막으면 안된다.

## 캡처링

- 실제 코드에서 자주 쓰이진 않지만, 종종 유용한 경우가 있다.
- 이벤트가 하위 요소로 전파되는 단계

## 이벤트 위임

- 이벤트 위임은 비슷한 방식으로 여러 요소를 다뤄야할 때 사용된다.
- 이벤트 위임은 다음과 같은 알고리즘으로 동작한다
  1. 컨테이너 하나의 핸들러를 할당한다
  2. 핸들러의 `event.target`을 사용해 이벤트가 발생한 요소가 어디인지 알아낸다.
  3. 원하는 요소에서 이벤트가 발생했다고 확인되면 이벤트를 핸들링한다.

#### 이벤트 위임 장점

- 많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절야된다.
- 요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아진다.
- `innerHTML`이나 유사한 기능을 하는 스크립트로 요소 덩어리를 더하거나 뺄 수 있기 때문에 DOM 수정이 쉬워진다

#### 이벤트 위임 단점

- 이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 합니다. 하지만 몇몇 이벤트는 버블링 되지 않습니다. 그리고 낮은 레벨에 할당한 핸들러엔 `event.stopPropagation()`를 쓸 수 없습니다.
- 컨테이너 수준에 할당된 핸들러가 응답할 필요가 있는 이벤트이든 아니든 상관없이 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있습니다. 그런데 이런 부하는 무시할만한 수준이므로 실제로는 잘 고려하지 않습니다.

## 커스텀 이벤트 디스패치

- 이벤트를 직접 만들 수 있으며, 이렇게 직접 만든 커스텀 이벤트는 `그래픽 컴포넌트`를 만들 때 사용된다.

#### Event의 생성자

- 내장 이벤트 클래스는 DOM요소 클래스같이 계층 구조를 형성한다. 내장 이벤트 클래스 계층의 꼭대기엔 `Event`클래스가 있다.
  > let event = new Event(type[, options]);
- `type` - 이벤트 타입을 나타내는 문자열로 `click`같은 내장 이벤트, `my-event` 같은 커스텀 이벤트가 올 수 있다.
- `options` - 두개의 선택 프로퍼티가 있는 객체가 온다.
  1. `bubbles: true/false` - `true`인 경우 이벤트가 버블린 된다.
  2. `cancelable: true/false` - `true`인 경우 브라우저 기본동작이 실행되지 않는다.

#### dispatchEvent

- 이벤트 객체를 생성한 다음엔 `elem.dispatchEvent(event)`를 호출해 요소에 있는 이벤트를 반드시 실행시켜 줘야한다.

## 커스텀 이벤트

- 제대로 된 커스텀 이벤트를 만들려면 `new CustomEvent`를 사용해야 한다.
- 내장 이벤트와 같은 이름을 가진 브라우저 이벤트를 만들지 말도록 합시다. 대부분의 경우 설계 관점에서 아주 좋지 않은 영항을 끼치기 때문이다.
- `CustomEvent`의 두 번째 인수엔 객체가 들어갈 수 있는데, 개발자는 이 객체에 `detail`이라는 프로퍼티를 추가해 커스텀 이벤트 관련 정보를 명시하고, 정보를 이벤트에 전달할 수 있다.
  > `detail`이라는 특별한 프로퍼티를 사용하는 이유는 다른 이벤트 프로퍼티와 충돌을 피하기 위해서다.
